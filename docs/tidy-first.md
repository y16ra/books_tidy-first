---
marp: true
theme: default
class: lead
paginate: true
---

# 「Tidy First?」勉強ノート

---

著者の主なポイント：
- 整頓はリファクタリングのサブセット（「小さなリファクタリング」）である
- 本来リファクタリングは「振る舞いを変更することなく構造を変更する」ことを指す
- 現在は「リファクタリング」という言葉が誤用され、長期的な開発中断や機能変更を含む作業を指すようになり、本来の意味が失われている
- 整頓とは、コードを小さく、安全なステップでリファクタリングすることであり、システムの将来の変更を容易にすることを目指すことである。


---

## 1章 ガード節

- ネストした条件を整理し、**コードの可読性を向上**させる
- **事前の条件を明確**にすることで、コードの分析を容易にする
- **ガード節の使いすぎ**はコードを読みにくくするため、注意が必要
- ガード節への整頓は、**条件を正しく満たせる場合のみ**行う

---

## 2章 デッドコード

- **実行されないコードは削除**する
- デッドコードの特定が難しい場合は、**使用状況のログを取得**し、確信が持てるまで待つ
- 削除したコードは、**バージョン管理システムで復元可能**
- 少しずつコードを削除することで、**間違いに気づいても簡単に変更を元に戻せる**

---

## 3章 シンメトリーを揃える

- **同じことをしているコード**は同じように、**違うことをしているコード**は違って見えるようにする
- 関連するコードを**きちんと読む順番**にまとめられるようにする

---

## 4章 新しいインターフェイス、古い実装

- 既存のインターフェイスが難しい場合、**自分が呼びたいインターフェイスを実装**し、それを呼ぶ
- **透過的なインターフェイス**を作ることは、ソフトウェア設計における最⼩単位の本質
- すべての呼び出し元を移⾏できたら、**実装をインライン化**できる

---

## 5章 読む順番

- ファイルを**読み手が遭遇したい順番**に並べ替える
- **理解や変更を必要以上に難しくしている点**に気づくことがあるかもしれないが、そこはあとで時間を取る
- 読んでいるうちに**他の整頓をする誘惑に負けない**

---

## 6章 凝集の順番

- 整頓によって**凝集度を高めれば、振る舞いの変更が簡単**になる
- 凝集度を高めれば、**分離の妨げとなっているものを取り除く**こともできる
- 凝集度を高めることで、**結合があっても平気でいられる**ようにもなる

---

## 7章 変数宣言と初期化を一緒の場所に移動する

- 変数宣言と初期化を**同じ場所に配置**する
- 大きな設計変更は大変で怖いかもしれないが、**小さなステップで進める**

---

## 8章 説明変数

- 式の結果に**名前を付ける**ことで、コードの意図を明確にする

---

## 9章 説明定数

- コード中の理解できない数字や文字列の固定値を、**シンボリック定数**に置き換える

---

## 第10章「明示的なパラメーター」

- **コードを読んでいて、ルーチンに明示的に渡されていないデータがある場合、ルーチンを分割し、パラメーターを上位に集めて明示的に渡す**

- パラメーターをマップで渡すと、必要なデータの把握が難しくなり、**後で暗黙的に使用するためにパラメーターが不正に使用される可能性**がある

- **コードの奥深くで環境変数が利用されている場合、パラメーターを明示的にして呼び出し関数のチェーンの上位に持っていく**

- fooを分割することで、パラメーターを明示的にする例が示されている

- params = { a: 1, b: 2 }というコードがあるとする。foo(params)というコードを分割することで、パラメーターを明示的にする

---

## 11章 ステートメントを小分けにする

- 大きなコードのチャンクを読んでいると、「ああ、ここはこれをしているんだな」とわかる。その間に**空行を入れ**よう
- ソフトウェア設計を**大げさなものにしてはいけない**
- ステートメントを小分けにしたら、説明変数、ヘルパーを抽出する、説明コメントなど、**他にもいろいろすることがある**

---

## 12章 ヘルパーを抽出する

- ルーチン内に、明確な⽬的を持ち、他のコードとの相互作⽤が限られているコードブロックがある場合、**ヘルパールーチンとして抽出**する
- （ルーチンがどのように機能するかではなく）**⽬的に合わせてルーチンに名前**をつける
- **メソッドの抽出**と考えることもできる
- 新しいインターフェイスは、私たちがより**抽象的に考え、デザインボキャブラリーに⾔葉を加える**準備ができたときに現れる

---

## 13章 ひとかたまり

- 細かく分割されているがゆえに、かえって理解を妨げているようなコードに出会うことはないだろうか。必要な範囲でなるべく多くのコードを**インライン化**して、⼤きなひとかたまりにしよう
- コードの最⼤のコストは、コードを書くことではない。**コードを読んで理解すること**だ
- 明確さを取り戻すには、まずはコードを**1箇所に集めて**、それから改めて、簡単に理解できる部品を抽出する

---

## 14章 説明コメント

- コードからは読み取れないことを**書いておく**
- **未来の読み⼿**や15分前の⾃分⾃⾝の⽴場に⽴ってみる
- あなたとは違うタイプの⼈だとしても、**特定の誰かに向けて書こう**

---

## 15章 冗長なコメントを削除する

- コードに書いてあることをそのまま書いてあるコメントがあったら、**消そう**
- コードの⽬的は、コンピューターに何をさせたいのかを**他のプログラマーに説明すること**だ
- 完全に**冗⻑なコメント**は消そう

---

## 16章 分けて整頓する

- 整頓はそれ⽤の**プルリクエストに⼊れる**
- 整頓はプルリクエストごとに**できるだけ少数**にする
- ステートメントを⼩分けにすると**説明ヘルパー**ができ、振る舞いの変更が簡単になる
- 整頓に慣れ、⼩さなステップで作業することに慣れたら、整頓のプルリクエストでは**レビューを必須にしない実験**をしてみよう

---

## 17章 連鎖

- 整頓はポテトチップスのようなものだ。**1つ⾷べれば、もう1つ⾷べたくなる**
- どのような⼤きさでステップを踏むかはあなた次第だが、**⼩さな整頓のステップ**にこだわって実験することをお勧めする
- 整頓で先の展開が⾒えるようになっていく。**さながらチェス**だ
- 読む順番が確⽴できたら、**シンメトリーを揃える**⽅法が⾒えてくるかもしれない
- 説明変数への代⼊の右側は、**説明ヘルパーの候補**だ

---

## 18章 バッチサイズ

- バッチあたりの整頓が増えるほど、統合までの時間が⻑くなり、**他の⼈の作業と衝突する機会が増⼤**する
- 同じように、整頓の数が増えるほど、バッチが**意図せず振る舞いを変更する可能性**も⾼くなる
- バッチあたりの整頓が増えるほど、特に深い理由もなく整頓をしがちになり、結果としてそれが**コストの増⼤**につながる
- レビューのコストを減らして、**バッチサイズを⼩さくすることによって整頓のコストを減らす**

---

## 19章 リズム

- 整頓するのは、将来システムの**振る舞いを変更するときに、それを簡単にする**ためだ
- 振る舞いを変更する前に1時間以上整頓するようだと、実現したい振る舞いの変更に必要な**最⼩の構造変更を⾒失っている可能性**が⾼い
- コードにおいて、振る舞いの変更は**⼀部に集中する傾向**にある

---

## 20章 絡まりを解きほぐす

- どんな振る舞いの変更が必要か**すべて理解**している
- どんな整頓が振る舞いの変更を簡単にするか**すべて理解**している
- 整頓と変更が**こんがらがってぐちゃぐちゃ**になっている
- 再実装するほど**新しい発⾒の可能性は⾼まり**、同じような振る舞いの変更からも多くの価値を引き出せるようになる
- ⽑⽷の⽟を解きほぐすのは、**絡まりがあることに気づくこと**から始まる

---

## 21章 先に整頓、あとに整頓、改めて整頓、整頓しない

- システムの振る舞いの変更に対する、**整頓のタイミング**について
- **コードの振る舞いをこの先絶対に、⼆度と変更することはない**なら、まったく整頓しない
- もしシステムのなかで**変更が保証されている領域**があり、そのあたりを整頓することで将来の変更を単純化できるのなら、価値がある
- **コードは⾃分がどのように構造化されたいかを「知って」いる**
- **今すぐ整頓**したほうが安くあがる
- **何をどのように整頓すればよいか**わかっている

---

## 22章 要素を役立つように関係づける

- 設計とは、**⼩さな⼦要素から単⼀の⼤きなものを作ること**だ
- ソフトウェア設計だと、以下を始めとしてたくさんの**関係性**がある
  - 呼び出す
  - 公開する
  - 待ち受ける
  - 参照する（変数の値を取得する）
- 要素同⼠の（暗黙の）関係性が多すぎると、**すぐに変更できなくなってしまう**

---

## 23章 構造と振る舞い

- ソフトウェアが価値を⽣み出す⽅法は2つある
  - **今⽇ソフトウェアが⾏うこと**
  - **明⽇ソフトウェアに⾏わせることができそうな新しいこと**
- **オプションはソフトウェアによる経済的な魔術**
- システムの構造は**その振る舞いには関係がない**
- **構造がオプションを⽣み出す**

---

## 24章 経済性：時間価値とオプショナリティ

- プログラマーとして理にかなっていることであっても、**お⾦の本質に反している**こともある
- お⾦の本質についての教えが直感に染み込むと、**プログラミングに対する考え⽅が変わっていく**
- 私が学んだ本質は、2つの驚くべき性質から成り⽴っていた
  - **今⽇の1ドルは明⽇の1ドルよりも価値があるので、早く稼ぎ、あとで使う**
  - **カオスな状況では、モノよりオプションのほうが優れているので、不確実性に対してオプションを作る**
- ソフトウェア設計は「**すぐに稼ぐ／あとで使う**」と「**モノではなくオプションを作る**」という要求を調和させなければいけない

---

## 25章 明日の1ドルより今日の1ドル

- 価値を⾜し合わせたければ、**それぞれのドルに⽇付**がついている必要がある
- あなたのソフトウェアシステムを私が買いたがっているとしたら、私が最初に聞くことは「**いつ？ どれくらい確実に？**」
- お⾦の時間価値が推奨しているのは、**先に整頓するよりもあとに整頓するほう**だ
- 時間価値の練習をしておけば、**今⽇お⾦を稼ぐことを選択する**のが得意になるだろう

---

## 26章 オプション

- より早く、より⾼い確率で、より多くのお⾦を稼ぐ。より遅く、より低い確率で、より少ないお⾦を費やす
- 「**次にどのような振る舞いを実装できるか**」は、実装する前から、それ⾃体に価値がある
- 価値予測の**不確実性が⾼いほど、オプションの価値は⾼い**
- ソフトウェア設計は**振る舞いの変更への準備**

---

## 第27章「オプション vs キャッシュフロー」

- **ディスカウントキャッシュフロー**の観点では早く確実にお金を稼ぎ後で使うべきで、**先に整頓は避ける**

- **オプションの観点**では**今お金を使って後で稼ぐ**ことを重視し、**先に整頓**を推奨

- 先に整頓すべき判断基準：`cost(整頓) + cost(整頓後の変更) < cost(整頓なしの変更)`

- 将来の**変更容易性**のために先に整頓することは、オプション価値が早期収益を上回る場合に経済的に合理的

- 短時間の整頓では経済性計算は困難だが、**設計のタイミングとスコープに影響するインセンティブを意識**することが重要

---

## 28章 可逆的な構造変更

- 構造の変更は**⼀般的に可逆的**である
- 可逆的な決定についてはどうだろうか？ ソフトウェアの設計判断のほとんどは、簡単に戻せる
- コードレビューのプロセスでは、**可逆的な変更と不可逆的な変更を区別しない**

---

## 29章 結合

- ひとたび1つの変更が次の要素に波及すると、それに伴う変更がさらに多数の変更を引き起こし、それらの変更がさらなる変更を引き起こしていく
- カスケード変更の可能性や規模を減らすのは**あなたのソフトウェア設計**だ
- あるサービスに対するどんな変更が**別のサービスの変更を必要とするか**を知る必要がある

---

## 30章 コンスタンチンの等価性

- ソフトウェアのゴールは**ソフトウェアのコストを最⼩化**すること
- 未来のシステムの価値は**昨⽇の憶測ではなく今⽇の現実**のなかで明らかになる
- 既存システムが**摩擦を⽣み始めている**

---

## 31章 結合 vs 分離

- 結合は、夜のレゴのパーツのように、それを**踏むまで明らかでない**ことが多い
- システムに結合がある別の合理的な理由は、それが**まさに今まで問題でなかったから**だ

---

## 32章 凝集

- 結合した要素は**同じ親要素の⼦要素同⼠**であるべきだ
- まるで堆肥のようなぐちゃぐちゃで複雑なコードは**ひとかたまりに集めよう**
- 凝集していない要素（つまり結合していない要素）は**別の場所に移すべき**
- ヘルパー関数の抽出は、この⼿の「**凝集度の⾼い⼦要素を抽出する**」アプローチの⼀例
- ⼀度に**1つの要素**を動かそう

---

## 33章 結論

- 整頓によって**コスト**が⼩さくなったり、コストが発⽣する時期が遅くなったり、コストが発⽣する可能性が低くなったりするか？
- 整頓によって**収益**が⼤きくなったり、収益を⼿にする時期が早くなったり、収益を⽣む可能性が⾼くなったりするか？
- 整頓によってより**少ない要素の変更**になるか？
- 整頓によって変更が必要な要素が、より⼩さく、もっと**集中した範囲**になるか？
- 整頓はあなたの**プログラミングに平穏と満⾜、喜び**をもたらしてくれるだろうか？
- 先に整頓するときは、次を⾷べたいという**衝動を抑えよう**
- ソフトウェア設計を**ありふれたもの**にして、開発の⼀部としてバランスを取ってやっていけるようにすること

